<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <link rel="stylesheet" href="../..//css/default.css">
        <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
        <script src="https://code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <script src="../..//scripts/highlight.js"></script>
    </head>
    <body>
        <div class="container">
                        <div class="col-xs-12 col-sm-12 col-md-6 col-lg-4">
<h1 id="-a-name-referenceparser-referenceparser-a-"><a name="ReferenceParser">#ReferenceParser</a></h1>
                        </div>
                        <div class="col-xs-12 col-sm-12 col-md-6 col-lg-4">
<p> <a href="../.././authors.md.html#authors/chris">authors/chris</a> </p>
                        </div>
                        <div class="col-xs-12 col-sm-12 col-md-6 col-lg-8">
                            <pre><code class="typescript">import {IReferenceCollection, IAnchor, ReferenceCollection} from &quot;../classes/referenceCollection&quot;;import {IFile, ILine} from &quot;../classes/IFile&quot;;
import {getFileType} from &quot;../helpers/fileType&quot;;
import {writeFileSync, mkdirSync, accessSync, F_OK, openSync} from &quot;fs&quot;;
import mkdirp &#x3D; require(&quot;mkdirp&quot;);
import * as path from &quot;path&quot;;
import XRegExp &#x3D; require(&quot;xregexp&quot;);
import lineReader &#x3D; require(&quot;line-reader&quot;);
import Q &#x3D; require(&quot;q&quot;);
import {doInOrder, doNext} from &quot;../helpers/helpers&quot;;
import log4js &#x3D; require(&quot;log4js&quot;);
let logger &#x3D; log4js.getLogger(&quot;duly-noted::ReferenceParser&quot;);
export interface IReferenceParser {
    files: string[];
    parse(): any;
}
export class ReferenceParser implements IReferenceParser {
    files: string[];
    rootCollection: IReferenceCollection;
    anchorRegExp: RegExp;
    commentRegExp: RegExp;
    longCommentOpenRegExp: RegExp;
    longCommentLineRegExp: RegExp;
    longCommentCloseRegExp: RegExp;
    outputDir: string;
    constructor(files: string[],
        commentRegExp: RegExp,
        anchorRegExp: RegExp,
        longCommentOpenRegExp: RegExp,
        longCommentLineRegExp: RegExp,
        longCommentCloseRegExp: RegExp,
        outputDir: string) {
        logger.debug(&quot;ready&quot;);
        this.outputDir &#x3D; outputDir;
        this.files &#x3D; files;
        this.rootCollection &#x3D; new ReferenceCollection(path.basename(this.outputDir));
        this.anchorRegExp &#x3D; anchorRegExp;
        this.commentRegExp &#x3D; commentRegExp;
        this.longCommentOpenRegExp &#x3D; longCommentOpenRegExp;
        this.longCommentLineRegExp &#x3D; longCommentLineRegExp;
        this.longCommentCloseRegExp &#x3D; longCommentCloseRegExp;
    }
    public parse(): Q.Promise&lt;IReferenceCollection&gt; {
        let that &#x3D; this;
        return Q.Promise&lt;IReferenceCollection&gt;((resolve, reject) &#x3D;&gt; {
            logger.info(&quot;Starting parse actions for &quot; + that.files.length + &quot; files.&quot;);
            let parseActions &#x3D; [];
            for (let i &#x3D; 0; i &lt; that.files.length; i++) {
                let fileName &#x3D; that.files[i].split(&quot;.&quot;);
                let extension &#x3D; fileName[fileName.length - 1];
                if (extension &#x3D;&#x3D;&#x3D; &quot;md&quot;) {
                    parseActions.push(that.parseAsMarkdown(that.files[i]));
                } else {
                    parseActions.push(that.parseFile(that.files[i]));
                }
            }
            Q.all(parseActions)
            .then(() &#x3D;&gt; {
                logger.info(&quot;Saving out references.json&quot;);
                writeFileSync(path.join(that.outputDir, &quot;references.json&quot;), JSON.stringify(that.rootCollection), { flag: &quot;w&quot; });
                resolve(that.rootCollection);
            });
        });
    }
    parseAsMarkdown(fileName: string): Q.Promise&lt;{}&gt; {
        logger.info(&quot;parsing markdown file: &quot; + fileName);
        let that &#x3D; this;
        let file: IFile &#x3D; {
            name: fileName,
            type: &quot;markdown&quot;,
            lines: []
        };
</code></pre>
                        </div>
                        <div class="col-xs-12 col-sm-12 col-md-6 col-lg-4">
<p> Line numbering traditionally starts at 1</p>
                        </div>
                        <div class="col-xs-12 col-sm-12 col-md-6 col-lg-8">
                            <pre><code class="typescript">        let lineNumber &#x3D; 0;        return Q.Promise((resolve, reject) &#x3D;&gt; {
            lineReader.eachLine(fileName, (line, last) &#x3D;&gt; {
                let thisLine: ILine &#x3D; {
                    number: lineNumber
                };
                file.lines.push(thisLine);
</code></pre>
                        </div>
                        <div class="col-xs-12 col-sm-12 col-md-6 col-lg-4">
<p> In Markdown all lines are considered comments</p>
                        </div>
                        <div class="col-xs-12 col-sm-12 col-md-6 col-lg-8">
                            <pre><code class="typescript">                file.lines[lineNumber].comment &#x3D; line;                that.parseComment(file.lines[lineNumber].comment, fileName, lineNumber)
                .then(() &#x3D;&gt; {
                    if (last) {
                        that.writeOutFile(file)
                        .then(() &#x3D;&gt; {
                            resolve(null);
                            return false;
                        })
                        .catch((err) &#x3D;&gt; {
                            logger.fatal(err.message);
                        });
                    }
                });
                lineNumber++;
            });
        });
    }
    parseFile(fileName: string): Q.Promise&lt;{}&gt; {
        logger.info(&quot;parsing code file: &quot; + fileName);
        let that &#x3D; this;
        let file: IFile;
        let insideLongComment &#x3D; false;
        return Q.Promise((resolve, reject) &#x3D;&gt; {
</code></pre>
                        </div>
                        <div class="col-xs-12 col-sm-12 col-md-6 col-lg-4">
<p> read all lines:</p>
                        </div>
                        <div class="col-xs-12 col-sm-12 col-md-6 col-lg-8">
                            <pre><code class="typescript">                       logger.info(&quot;Working on file: &quot; + fileName);
            file &#x3D; {
                name: fileName,
                lines: [],
                type: getFileType(fileName)
            };
</code></pre>
                        </div>
                        <div class="col-xs-12 col-sm-12 col-md-6 col-lg-4">
<p> Line numbering traditionally starts at 1</p>
                        </div>
                        <div class="col-xs-12 col-sm-12 col-md-6 col-lg-8">
                            <pre><code class="typescript">            let lineNumber &#x3D; 0;            lineReader.eachLine(fileName, (line, last) &#x3D;&gt; {
                let thisLine: ILine &#x3D; {
                    number: lineNumber
                };
                file.lines.push(thisLine);
                let longCommentOpenMatch &#x3D; XRegExp.exec(line, that.longCommentOpenRegExp, 0, false);
</code></pre>
                        </div>
                        <div class="col-xs-12 col-sm-12 col-md-6 col-lg-4">
<p> These comments must come at beginning of line.</p>
                        </div>
                        <div class="col-xs-12 col-sm-12 col-md-6 col-lg-8">
                            <pre><code class="typescript">                if (!insideLongComment &amp;&amp; longCommentOpenMatch) {                    insideLongComment &#x3D; true;
                    file.lines[lineNumber].longComment &#x3D; true;
                }
</code></pre>
                        </div>
                        <div class="col-xs-12 col-sm-12 col-md-6 col-lg-4">
<p> Not inside a long comment - look for a regular comment.</p>
                        </div>
                        <div class="col-xs-12 col-sm-12 col-md-6 col-lg-8">
                            <pre><code class="typescript">                               if (!insideLongComment) {
                    let match &#x3D; XRegExp.exec(line, that.commentRegExp, 0, false);
</code></pre>
                        </div>
                        <div class="col-xs-12 col-sm-12 col-md-6 col-lg-4">
<p> Contains a tradition comment</p>
                        </div>
                        <div class="col-xs-12 col-sm-12 col-md-6 col-lg-8">
                            <pre><code class="typescript">                                       if (match) {
                        file.lines[lineNumber].comment &#x3D; match[1];
                        file.lines[lineNumber].code &#x3D; line.substr(0, match.index - 1);
                        that.parseComment(file.lines[lineNumber].comment, fileName, lineNumber)
                            .then(() &#x3D;&gt; {
                                if (last) {
                                    that.writeOutFile(file)
                                    .then(() &#x3D;&gt; {
                                        resolve(null);
                                        return false;
                                    })
                                    .catch((err) &#x3D;&gt; {
                                        logger.fatal(err.message);
                                    });
                                }
                            });
</code></pre>
                        </div>
                        <div class="col-xs-12 col-sm-12 col-md-6 col-lg-4">
<p> Not a comment (code only)</p>
                        </div>
                        <div class="col-xs-12 col-sm-12 col-md-6 col-lg-8">
                            <pre><code class="typescript">                                           } else {
                        file.lines[lineNumber].code &#x3D; line;
                        if (last) {
                            that.writeOutFile(file)
                            .then(() &#x3D;&gt; {
                                resolve(null);
                                return false;
                            })
                            .catch((err) &#x3D;&gt; {
                                logger.fatal(err.message);
                            });
                        }
                    }
</code></pre>
                        </div>
                        <div class="col-xs-12 col-sm-12 col-md-6 col-lg-4">
<p> Inside a long comment - so the whole thing is a comment</p>
                        </div>
                        <div class="col-xs-12 col-sm-12 col-md-6 col-lg-8">
                            <pre><code class="typescript">                } else {</code></pre>
                        </div>
                        <div class="col-xs-12 col-sm-12 col-md-6 col-lg-4">
<p> If this line contains a long comment closing symbol, then next line isn&#39;t long comment.</p>
                        </div>
                        <div class="col-xs-12 col-sm-12 col-md-6 col-lg-8">
                            <pre><code class="typescript">                   </code></pre>
                        </div>
                        <div class="col-xs-12 col-sm-12 col-md-6 col-lg-4">
<p> let longCommentEnd = line.search(that.longCommentCloseRegExp);</p>
                        </div>
                        <div class="col-xs-12 col-sm-12 col-md-6 col-lg-8">
                            <pre><code class="typescript">                                       if (XRegExp.exec(line, this.longCommentCloseRegExp, 0)) {
                        file.lines[lineNumber].comment &#x3D; &quot;&quot;;
                        insideLongComment &#x3D; false;
                    } else {
                        file.lines[lineNumber].longComment &#x3D; true;
                        if (longCommentOpenMatch) {
                            file.lines[lineNumber].comment &#x3D; longCommentOpenMatch[1].trim();
                        } else {
                            let match &#x3D; XRegExp.exec(line, this.longCommentLineRegExp, 0);
                            file.lines[lineNumber].comment &#x3D; match[1].trim() || line;
                        }
                        that.parseComment(line, fileName, lineNumber)
                        .then(() &#x3D;&gt; {
                            if (last) {
                                that.writeOutFile(file)
                                    .then(() &#x3D;&gt; {
                                        resolve(null);
                                        return false;
                                    })
                                    .catch((err) &#x3D;&gt; {
                                        logger.fatal(err.message);
                                    });
                            }
                        });
                    }
                    if (last) {
                        that.writeOutFile(file)
                        .then(() &#x3D;&gt; {
                            resolve(null);
                            return false;
                        })
                        .catch((err) &#x3D;&gt; {
                            logger.fatal(err.message);
                        });
                    }
                }
                lineNumber++;
            });
        });
    }
    writeOutFile(file: IFile) {
        let that &#x3D; this;
        return Q.Promise&lt;{}&gt;((resolve, reject) &#x3D;&gt; {
            let filePathArray &#x3D; path.join(that.outputDir, file.name + &quot;.json&quot;).split(&quot;/&quot;);
            filePathArray.pop();
            let filePath &#x3D; filePathArray.join(&quot;/&quot;);
            mkdirp(filePath, function (err) {
                if (err) {
                    logger.fatal(err.message);
                    reject(err);
                }
                else {
                    logger.info(&quot;Saving output for: &quot; + file.name);
                    writeFileSync(path.join(that.outputDir, file.name + &quot;.json&quot;), JSON.stringify(file), { flag: &quot;w&quot; });
                    resolve(null);
                }
            });
        });
    }
    parseLine(line: string, fileName: string, lineNumber: number, insideLongComment: boolean): Q.Promise&lt;{}&gt; {
        let that &#x3D; this;
        return Q.Promise&lt;string[]&gt;((resolve, reject) &#x3D;&gt; {
            let commentStart &#x3D; line.search(that.commentRegExp);
        });
    }
    parseComment(comment: string, fileName: string, lineNumber: number): Q.Promise&lt;{}&gt; {
        let that &#x3D; this;
        return Q.Promise&lt;{}&gt;((resolve, reject) &#x3D;&gt; {
            let pos &#x3D; 0;
            let match;
            while (match &#x3D; XRegExp.exec(comment, that.anchorRegExp, pos, false)) {
                logger.debug(&quot;found anchor: &quot; + match[1]);
                let parts &#x3D; match[1].split(&quot;/&quot;);
                that.rootCollection.addAnchorTag(parts, fileName, lineNumber);
                resolve(null);
                pos &#x3D; match.index + match[0].length;
            }
            resolve(null);
        });
    };
}
</code></pre>
                        </div>
        </div>
        <script type="text/javascript">
            (function(){
                console.log("loaded");
                hljs.configure({
                    tabReplace: '  '
                });
                hljs.initHighlighting();
            })();
        </script>
    </body>
</html>