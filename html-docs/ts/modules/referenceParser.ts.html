<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <link rel="stylesheet" href="../..//css/default.css">
        <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
        <script src="https://code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <script src="../..//scripts/highlight.js"></script>
        <style>
            body {
                padding-top: 50px;
            }
            .starter-template {
                padding: 40px 15px;
                text-align: center;
            }
            pre {
                display: block;
                padding: 0;
                margin: 0 0 30px 0;
                font-size: 11px;
                line-height: 1.42857143;
                color: #333;
                word-break: break-all;
                word-wrap: break-word;
                border: 1px solid #ccc;
                border-radius: 4px;
            }
        </style>
    </head>
    <body>
        <nav class="navbar navbar-inverse navbar-fixed-top">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand" href="../..//index.html">Duly-Noted</a>
                </div>
                <div id="navbar" class="collapse navbar-collapse">
                    <ul class="nav navbar-nav">
                       
                    </ul>
                </div>
            </div>
        </nav>

        <div class="container">
            <div class="row">    
            
                    <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                    <h1 id="-a-name-referenceparser-span-class-glyphicon-glyphicon-link-aria-hidden-true-span-referenceparser-a-"><a name="ReferenceParser"><span class="glyphicon glyphicon-link" aria-hidden="true"></span>ReferenceParser</a></h1>
<p> <a href="../.././authors.md.html#authors/chris">authors/chris</a> </p>

                    </div>

            </div>
            <div class="row">    
            

                    <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                        <pre>
                            <code class="typescript">import {IReferenceCollection, IAnchor, ReferenceCollection} from &quot;../classes/referenceCollection&quot;;
import {Config, IExternalReference} from &quot;../classes/IConfig&quot;;
import {IFile, ILine} from &quot;../classes/IFile&quot;;
import {getFileType} from &quot;../helpers/fileType&quot;;
import {writeFileSync, mkdirSync, accessSync, F_OK, openSync} from &quot;fs&quot;;
import mkdirp &#x3D; require(&quot;mkdirp&quot;);
import * as path from &quot;path&quot;;
import XRegExp &#x3D; require(&quot;xregexp&quot;);
import lineReader &#x3D; require(&quot;line-reader&quot;);
import Q &#x3D; require(&quot;q&quot;);
import {doInOrder, doNext} from &quot;../helpers/helpers&quot;;
import log4js &#x3D; require(&quot;log4js&quot;);
let logger &#x3D; log4js.getLogger(&quot;duly-noted::ReferenceParser&quot;);
export interface IReferenceParser {
    files: string[];
    parse(): any;
}
export const parseLoc &#x3D; &quot;duly-noted&quot;;
export class ReferenceParser implements IReferenceParser {
    files: string[];
    rootCollection: IReferenceCollection;
    anchorRegExp: RegExp;
    commentRegExp: RegExp;
    longCommentOpenRegExp: RegExp;
    longCommentLineRegExp: RegExp;
    longCommentCloseRegExp: RegExp;
    externalReferences: IExternalReference[];
    constructor(config: Config) {
        logger.debug(&quot;ready&quot;);
        this.files &#x3D; config.files;
        this.rootCollection &#x3D; new ReferenceCollection(parseLoc);
        this.anchorRegExp &#x3D; new RegExp(config.anchorRegExp);
        this.commentRegExp &#x3D; new RegExp(config.commentRegExp);
        this.longCommentOpenRegExp &#x3D; new RegExp(config.longCommentOpenRegExp);
        this.longCommentLineRegExp &#x3D; new RegExp(config.longCommentLineRegExp);
        this.longCommentCloseRegExp &#x3D; new RegExp(config.longCommentCloseRegExp);
        this.externalReferences &#x3D; config.externalReferences;
    }
    public parse(): Q.Promise&lt;IReferenceCollection&gt; {
        let that &#x3D; this;
        return Q.Promise&lt;IReferenceCollection&gt;((resolve, reject) &#x3D;&gt; {
            logger.info(&quot;Starting parse actions for &quot; + that.files.length + &quot; files.&quot;);
            let parseActions &#x3D; [];
            for (let i &#x3D; 0; i &lt; that.files.length; i++) {
                let fileName &#x3D; that.files[i].split(&quot;.&quot;);
                let extension &#x3D; fileName[fileName.length - 1];
                if (extension &#x3D;&#x3D;&#x3D; &quot;md&quot;) {
                    parseActions.push(that.parseAsMarkdown(that.files[i]));
                } else {
                    parseActions.push(that.parseFile(that.files[i]));
                }
            }
            Q.all(parseActions)
            .then(() &#x3D;&gt; {
                logger.info(&quot;Saving out internalReferences.json&quot;);
                writeFileSync(path.join(parseLoc, &quot;internalReferences.json&quot;), JSON.stringify(that.rootCollection), { flag: &quot;w&quot; });
                writeFileSync(path.join(parseLoc, &quot;externalReferences.json&quot;), JSON.stringify(that.externalReferences), { flag: &quot;w&quot; });
                resolve(that.rootCollection);
            });
        });
    }
    parseAsMarkdown(fileName: string): Q.Promise&lt;{}&gt; {
        logger.info(&quot;parsing markdown file: &quot; + fileName);
        let that &#x3D; this;
        let file: IFile &#x3D; {
            name: fileName,
            type: &quot;markdown&quot;,
            lines: []
        };</code>
                        </pre>
                    </div>
            </div>
            <div class="row">    
            
                    <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                    <p> Line numbering traditionally starts at 1</p>

                    </div>

            </div>
            <div class="row">    
            

                    <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                        <pre>
                            <code class="typescript">        let lineNumber &#x3D; 0;
        return Q.Promise((resolve, reject) &#x3D;&gt; {
            lineReader.eachLine(fileName, (line, last) &#x3D;&gt; {
                let thisLine: ILine &#x3D; {
                    number: lineNumber
                };
                file.lines.push(thisLine);</code>
                        </pre>
                    </div>
            </div>
            <div class="row">    
            
                    <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                    <p> In Markdown all lines are considered comments</p>

                    </div>

            </div>
            <div class="row">    
            

                    <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                        <pre>
                            <code class="typescript">                file.lines[lineNumber].comment &#x3D; line;
                that.parseComment(file.lines[lineNumber].comment, fileName, lineNumber)
                .then(() &#x3D;&gt; {
                    if (last) {
                        that.writeOutFile(file)
                        .then(() &#x3D;&gt; {
                            resolve(null);
                            return false;
                        })
                        .catch((err) &#x3D;&gt; {
                            logger.fatal(err.message);
                        });
                    }
                });
                lineNumber++;
            });
        });
    }
    parseFile(fileName: string): Q.Promise&lt;{}&gt; {
        logger.info(&quot;parsing code file: &quot; + fileName);
        let that &#x3D; this;
        let file: IFile;
        let insideLongComment &#x3D; false;
        return Q.Promise((resolve, reject) &#x3D;&gt; {</code>
                        </pre>
                    </div>
            </div>
            <div class="row">    
            
                    <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                    <p> read all lines:</p>

                    </div>

            </div>
            <div class="row">    
            

                    <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                        <pre>
                            <code class="typescript">           
            logger.info(&quot;Working on file: &quot; + fileName);
            file &#x3D; {
                name: fileName,
                lines: [],
                type: getFileType(fileName)
            };</code>
                        </pre>
                    </div>
            </div>
            <div class="row">    
            
                    <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                    <p> Line numbering traditionally starts at 1</p>

                    </div>

            </div>
            <div class="row">    
            

                    <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                        <pre>
                            <code class="typescript">            let lineNumber &#x3D; 0;
            lineReader.eachLine(fileName, (line, last) &#x3D;&gt; {
                let thisLine: ILine &#x3D; {
                    number: lineNumber
                };
                file.lines.push(thisLine);
                let longCommentOpenMatch &#x3D; XRegExp.exec(line, that.longCommentOpenRegExp, 0, false);</code>
                        </pre>
                    </div>
            </div>
            <div class="row">    
            
                    <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                    <p> These comments must come at beginning of line.</p>

                    </div>

            </div>
            <div class="row">    
            

                    <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                        <pre>
                            <code class="typescript">                if (!insideLongComment &amp;&amp; longCommentOpenMatch) {
                    insideLongComment &#x3D; true;
                    file.lines[lineNumber].longComment &#x3D; true;
                }</code>
                        </pre>
                    </div>
            </div>
            <div class="row">    
            
                    <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                    <p> Not inside a long comment - look for a regular comment.</p>

                    </div>

            </div>
            <div class="row">    
            

                    <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                        <pre>
                            <code class="typescript">               
                if (!insideLongComment) {
                    let match &#x3D; XRegExp.exec(line, that.commentRegExp, 0, false);</code>
                        </pre>
                    </div>
            </div>
            <div class="row">    
            
                    <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                    <p> Contains a tradition comment</p>

                    </div>

            </div>
            <div class="row">    
            

                    <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                        <pre>
                            <code class="typescript">                   
                    if (match) {
                        file.lines[lineNumber].comment &#x3D; match[1];
                        file.lines[lineNumber].code &#x3D; line.substr(0, match.index - 1);
                        that.parseComment(file.lines[lineNumber].comment, fileName, lineNumber)
                            .then(() &#x3D;&gt; {
                                if (last) {
                                    that.writeOutFile(file)
                                    .then(() &#x3D;&gt; {
                                        resolve(null);
                                        return false;
                                    })
                                    .catch((err) &#x3D;&gt; {
                                        logger.fatal(err.message);
                                    });
                                }
                            });</code>
                        </pre>
                    </div>
            </div>
            <div class="row">    
            
                    <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                    <p> Not a comment (code only)</p>

                    </div>

            </div>
            <div class="row">    
            

                    <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                        <pre>
                            <code class="typescript">                       
                    } else {
                        file.lines[lineNumber].code &#x3D; line;
                        if (last) {
                            that.writeOutFile(file)
                            .then(() &#x3D;&gt; {
                                resolve(null);
                                return false;
                            })
                            .catch((err) &#x3D;&gt; {
                                logger.fatal(err.message);
                            });
                        }
                    }</code>
                        </pre>
                    </div>
            </div>
            <div class="row">    
            
                    <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                    <p> Inside a long comment - so the whole thing is a comment</p>

                    </div>

            </div>
            <div class="row">    
            

                    <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                        <pre>
                            <code class="typescript">                } else {</code>
                        </pre>
                    </div>
            </div>
            <div class="row">    
            
                    <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                    <p> If this line contains a long comment closing symbol, then next line isn&#39;t long comment.</p>

                    </div>

            </div>
            <div class="row">    
            

                    <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                        <pre>
                            <code class="typescript">                   </code>
                        </pre>
                    </div>
            </div>
            <div class="row">    
            
                    <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                    <p> let longCommentEnd = line.search(that.longCommentCloseRegExp);</p>

                    </div>

            </div>
            <div class="row">    
            

                    <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                        <pre>
                            <code class="typescript">                   
                    if (XRegExp.exec(line, this.longCommentCloseRegExp, 0)) {
                        file.lines[lineNumber].comment &#x3D; &quot;&quot;;
                        insideLongComment &#x3D; false;
                    } else {
                        file.lines[lineNumber].longComment &#x3D; true;
                        if (longCommentOpenMatch) {
                            file.lines[lineNumber].comment &#x3D; longCommentOpenMatch[1].trim();
                        } else {
                            let match &#x3D; XRegExp.exec(line, this.longCommentLineRegExp, 0);
                            file.lines[lineNumber].comment &#x3D;  &quot; &quot; + match[1].trim() || line;
                        }
                        that.parseComment(line, fileName, lineNumber)
                        .then(() &#x3D;&gt; {
                            if (last) {
                                that.writeOutFile(file)
                                    .then(() &#x3D;&gt; {
                                        resolve(null);
                                        return false;
                                    })
                                    .catch((err) &#x3D;&gt; {
                                        logger.fatal(err.message);
                                    });
                            }
                        });
                    }
                    if (last) {
                        that.writeOutFile(file)
                        .then(() &#x3D;&gt; {
                            resolve(null);
                            return false;
                        })
                        .catch((err) &#x3D;&gt; {
                            logger.fatal(err.message);
                        });
                    }
                }
                lineNumber++;
            });
        });
    }
    writeOutFile(file: IFile) {
        let that &#x3D; this;
        return Q.Promise&lt;{}&gt;((resolve, reject) &#x3D;&gt; {
            let filePathArray &#x3D; path.join(parseLoc, file.name + &quot;.json&quot;).split(&quot;/&quot;);
            filePathArray.pop();
            let filePath &#x3D; filePathArray.join(&quot;/&quot;);
            mkdirp(filePath, function (err) {
                if (err) {
                    logger.fatal(err.message);
                    reject(err);
                }
                else {
                    logger.info(&quot;Saving output for: &quot; + file.name);
                    writeFileSync(path.join(parseLoc, file.name + &quot;.json&quot;), JSON.stringify(file), { flag: &quot;w&quot; });
                    resolve(null);
                }
            });
        });
    }
    parseLine(line: string, fileName: string, lineNumber: number, insideLongComment: boolean): Q.Promise&lt;{}&gt; {
        let that &#x3D; this;
        return Q.Promise&lt;string[]&gt;((resolve, reject) &#x3D;&gt; {
            let commentStart &#x3D; line.search(that.commentRegExp);
        });
    }
    parseComment(comment: string, fileName: string, lineNumber: number): Q.Promise&lt;{}&gt; {
        let that &#x3D; this;
        return Q.Promise&lt;{}&gt;((resolve, reject) &#x3D;&gt; {
            let pos &#x3D; 0;
            let match;
            while (match &#x3D; XRegExp.exec(comment, that.anchorRegExp, pos, false)) {
                logger.debug(&quot;found anchor: &quot; + match[1]);
                let parts &#x3D; match[1].split(&quot;/&quot;);
                that.rootCollection.addAnchorTag(parts, fileName, lineNumber);
                resolve(null);
                pos &#x3D; match.index + match[0].length;
            }
            resolve(null);
        });
    };
}</code>
                        </pre>
                    </div>
            </div>
        <script type="text/javascript">
            (function(){
                console.log("loaded");
                hljs.configure({
                    tabReplace: '  '
                });
                hljs.initHighlighting();
            })();
        </script>
    </body>
</html>